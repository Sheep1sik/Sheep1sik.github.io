---
title:  "[ 필기 ] 주기억장치 관리 전략 " 

categories:
  - Data processing
tags:
  - [주기억장치, 정보처리산업기사, 자격증]

toc: true
toc_sticky: true

date: 2022-02-24
last_modified_at: 2022-02-24
---
강의를 듣고 정리한 필기입니다. 😀 지식 공유보단 개인적인 복습을 목적으로 포스팅하였습니다.

---
## 1. 반입(Fetch) 전략
	프로그램/데이터를 주기억장치로 가져오는 시기(When)를 결정하는 전략
	
### 요구 반입(Demand fetch)
	요구 반입 기법은 새로 반입된 데이터나 프로그램을 주기억장치의 언제 위치시킬 것인가를 결정하는 방법이다.
### 예상 반입(Anticipatory fetch)
	앞으로 요구될 가능성이 큰 데이터 또는 프로그램을 예상하여 주기억장치로 미리 옮기는 방법이다.

## 2. 배치(Placement) 전략
	프로그램/데이터의 주기억장치 내의 위치(Where)를 정하는 전략이다.
	최초적합, 최적적합, 최악적합이 있다.
	
### 최초 적합(First Fit)
	입력된 작업을 주기억장치 내에서 그 작업을 수용할 수 있는 첫 번째 공백에 배치한다.
	초기 결정력이 가장 빠르다.
	운영체제 다음부터가 시작점이다.
	처음부터 순차적으로 검색하여 적재될 수 있는 공백이면 배치한다.
			
### 최적 적합(Best Fit)
	입력된 작업을 주기억장치 내의 공백 중에서 그 작업에 가장 잘 맞는 공백에 배치한다.
	내부 단편화가 가장 작거나 없는 공백에 배치한다.
	가장 잘 맞는 공백을 찾아야 하므로 결정력이 느리다.

### 최악 적합(Worst Fit)
	입력된 작업을 주기억장치 내에서 가장 잘 맞지 않는 공백,
	즉 가장 큰 공백에 배치한다.
	내부 단편화가 가장 큰 공백에 배치한다.
	가장 잘 맞지 않는 공백을 찾아야 하므로 결정력이 느리다.

### 3. 교체(Replacement) 전략( 페이지 교체 알고리즘)
	당장 필요한 페이지와 교체할 페이지를 선택하는 전략이다.

	주기억장치에 적재된 페이지들을 대상으로 새롭게 적재될 페이지와 교체할 페이지를 선택하는 전략이다.
	당장 적재할 페이지가 주기억장치내의 페이지 프레임에 있으면 성공(Hit) 되었다고 한다.
	당장 적재할 페이지가 주기억장치내의 페이지 프레임에 없으면 실패 혹은 페이지 부재(Page Fault)되었다고 한다.
	페이지 적중률(Hit Ratio)이 높도록 교체 전략을 선택해야 한다.
	페이지 적중률 = 성공수 / 페이지 참조 수
	효율적인 교체 전략은 프로그램의 실행속도를 향상시킨다.

### 3-1 교체 전략의 종류
	
#### 최적화 
	앞으로 가장 오랫동안 사용되지 않을 페이지와 교체한다.
	앞으로 사용할 페이지를 미리 확인하여 교체하는 방법이다.
    실제 알고리즘에서는 미리 확인할 수 없다.
	Belady의 알고리즘으로 가장 이상적이지만 실현가능성이 희박하다.
	페이지 부재(Page Fault) 횟수가 가장 적으므로 페이지 적중률이 가장 크다.

<img width="607" alt="Pasted Graphic 17" src="https://user-images.githubusercontent.com/88019314/155454290-9c39b9c4-2c3c-48fd-934f-dcc17b49e01f.png">
<br>

#### FIFO
	주기억장치 내에 가장 오래 있던 페이지와 교체한다.
	각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 두고, 주기억장치 내에 가장 오래 있던 페이지를 교체한다.
	알고리즘이 가장 간단하다.
	페이지 부재가 가장 많이 발생한다.

	Belady 모순 : 프로세스에 할당된 페이지 프레임 수가 증가하면서 페이지 부재의 수가 감소하는 것이 당연하지만
	페이지 프레임 수가 증가할 때, 현실적으로 페이지 부재가 더 증가하는 모순(Anomaly) 현상이 발생한다.

<img width="616" alt="Pasted Graphic 18" src="https://user-images.githubusercontent.com/88019314/155454413-7598a40c-bbb7-4e8a-9873-ea8420b1f874.png">
<br>

#### LRU
	사용(참조된)한 지 가장 오래된 페이지를 대상으로 교체한다.
	현시점에서 가장 오랫동안 사용하지 않은 페이지와 교체한다.
	각 페이지마다 계수기(시간 기억 영역)를 두어 사용하는 기법
    
<img width="598" alt="Pasted Graphic 19" src="https://user-images.githubusercontent.com/88019314/155454423-1d0504c8-c724-4d04-aa21-9497854ffd04.png">
<br>

#### LFU
	사용(참조된)한 횟수가 가장 적은 페이지와 교체한다.
	사용한 횟수를 기억할만한 참조변수를 각 페이지마다 갖게 하여 사용할 때마다 1씩 증가한다.	
<img width="703" alt="Pasted Graphic 20" src="https://user-images.githubusercontent.com/88019314/155454436-93ebde6b-c78f-4833-b8a2-02da433e61dc.png">
<br>

#### NUR
	최근에 호출하지도 사용하지도 않은 페이지를 제거한다.
	두 개의 하드웨어 비트인 참조 비트(Referenced Bit)와 변형 비트(Modified Bit)를 사용한다.
	참조 비트가 0이면 오래전에 호출, 1이면 최근에 호출한 것이다.
	변형 비트가 0이면 오래전에 사용, 1이면 최근에 사용한 것이다.
	참조 비트와 변형 비트는 주기적으로 갱신된다.

<img width="512" alt="Pasted Graphic 21" src="https://user-images.githubusercontent.com/88019314/155454443-0d9fb76a-8eb9-4ad6-89f8-bb085299d8b7.png">
<br>

#### Second Chance(이차 기회)
	가장 오래된 페이지가 최근에 사용할 가능성이 높을 것이라는 가정 하에
	가장 오래된 페이지는 교체 대상에서 제외하고 사용한 것으로 취급한다.
	각 페이지의 프레임을 FIFO 순으로 유지시키면서 LRU와 근사 알고리즘처럼 참조 변수를 갖게 한다.
	FIFO의 2차 기회부여 방식이다. 
			

#### PFF
	워킹 셋에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 워킹 셋에 속하지 않은 페이지 중에
	최근에 자주 사용하는 페이지와 교체한다.
***
<br>

    개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}