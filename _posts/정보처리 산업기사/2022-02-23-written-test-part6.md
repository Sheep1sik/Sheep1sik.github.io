---
title:  "[ 필기 ] 프로세스 스케줄링(Process Scheduling) Part.1 " 

categories:
  - Data processing
tags:
  - [프로세스 스케줄링, 정보처리산업기사, 자격증]

toc: true
toc_sticky: true

date: 2022-02-23
last_modified_at: 2022-02-23
---
강의를 듣고 정리한 필기입니다. 😀 지식 공유보단 개인적인 복습을 목적으로 포스팅하였습니다.

---

## 1. 프로세스 스케줄링의 정의
	CPU나 자원을 효과적이며 생산성 있게 사용하기 위한 소프트웨어적 계획이다.
	프로세스 스케줄링은 프로세스에게 CPU를 할당하고 문맥 교환을 하는 프로세스 관리 기능이다

## 2. 프로세스 스케줄링의 종류

### 2-1 장기(상위) 스케줄링
	프로세스가 자원을 사용하는 시기를 결정하여 대기 큐로 전달하는 작업으로, 작업 스케줄러(Job Scheduling, Long Term Scheduling)라고 한다.
	프로그램들이 주기억장치에 적재될 시기를 결정하는 것과 같은 스케줄링으로 다소 느린 작업 계획이다.

### 2-2 중기(중위) 스케줄링
	프로세스가 여러 개의 CPU 중에 어떤 CPU를 할당 받을 것인가를 결정하는 작업이다.
	어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 일을 담당한다.
	이 스케줄러는 프로세스를 주기억 장치로부터 빼낼 수 있기 때문에 필요한 경우에는 다중 프로그래밍의 정도를 낮추어 시스템의 전반적인 효율을 높여 주거나,
	특정 프로세스에 대한 처리를 원활하게 해 줄 수 있는 효과를 얻을 수 있다.

###2-3 단기(하위) 프로세스
	여러 개의 프로세스가 하나의 CPU를 점유하기 위한 시기를 결정하기 위한 작업으로 
	프로세스 스케줄링(Processing Scheduling, Short Term Scheduling)이라고 한다.
	디스패치, 인터럽트를 통한 문맥교환 등을 수행하는 것처럼 짧은 시간에 처리해야 하는 작업 계획이다.

## 3. 프로세스 스케줄링의 원칙
	모든 프로세스들에게 공정하게 배정해야한다.
	단위 시간당 가능한 최대의 처리가 될 수 있도록 해야 한다.
	처리 응답시간이 신속해야 한다.
	같은 종류의 작업은 같은 비용으로 실행될 수 있어야 한다.
	오버헤드를 최소화해야 한다.
	시스템 내의 자원이 사용하지 않는 시간이 없도록 유지해야 한다.
	응답시간과 자원의 활용간의 적절한 균형을 유지되도록 해야 한다.
	프로세스의 무한대기 상태를 피해야한다.
	프로세스의 상태를 파악하여 우선순위를 부여하는 것이 좋다.
	중요 자원을 차지하고 있는 프로세스에게 우선순위를 주어야 한다.
	문제로 인해 불안하지 않은 프로세스에게 서비스를 많이 제공하도록 한다.

## 4. 프로세스 스케줄링의 성능 평가 기준(바람직한 스케줄링 정책)

<img width="444" alt="Pasted Graphic 19" src="https://user-images.githubusercontent.com/88019314/155252720-72db33d3-8c88-430b-b2d6-c059bb82b3cc.png">
<br>

### 4-1 CPU 이용률
	CPU를 쉬지 않고 몇 퍼센트 (범위 40% ~ 90%)를 이용하는가의 기준(늘림)

### 4-2 처리능력(Throughput)
	단위 시간당 처리할 수 있는 CPU의 작업량 늘림

### 4-3 대기시간(Waiting time)
	준비 상태에서 대기하는 시간(줄임)

### 4-4 응답시간(Response time, 반응시간)
	입력에 대해 처음 반응하는 시간(줄임)

### 4-5 반환시간(Turn around time)
	작업을 지시하고 그 결과가 되돌어오는 시간(줄임)

### 5. 비선점형 방식과 선점형 방식

### 5-1 비선점형(Non Preemption) 방식
	CPU를 점유하고 있을 때에는 다른 프로세스가 현재 실행 중인 프로세스를 중단시킬 수 없다.
	일단 CPU를 할당받으면 다른 프로세스가 CPU를 강제적으로 빼앗을 수 없는 방식이다.
	CPU를 사용하고 있는 현재의 프로세스가 종료된 후 다른 프로세스에 CPU를 할당한다.
	실행이 완료될 때까지 CPU를 독점하는 방식이다.
	비선점형 방식들은 모든 프로세스를 관리하는데 공정하다.
	공정하며 프로세스의 실행 예측 치를 미리 통보하고, 프로세스를 수행한다면 응답시간의 예측이 용이하다.
	일괄 처리 시스템에 적당하다.

### 5-2 선점형(Preemption) 방식
	하나의 프로세스가 CPU를 점유하고 있을 때에는 다른 프로세스가 현재 사용 중인 프로세스를 중단시키고 CPU를 차지할 수 있는 방식이다.
	CPU를 할당받은 프로세스를 다른 프로세스가 CPU를 강제적으로 빼앗을 수 있는 방식이다.
	선점형 방식들은 높은 우선순위의 프로세스들이 긴급을 요할 때 유용하다.
	빠른 응답시간을 필요로 하는 대화식, 시분할, 실시간 처리에 적당하다.

### 5-3 비선점형 방식과 선점형 방식의 종류

<img width="595" alt="RR, SRT  MFQ" src="https://user-images.githubusercontent.com/88019314/155252893-58d4bc89-f0c8-4b83-a128-c2145cc07086.png">
<br>

### 5-4 FIFO(First Input First Output, FCFS) - 비선점형

#### 5-4-1 FIFO의 특징
	입력된 순으로 처리되기 때문에 공평하다.
	알고리즘이 가장 간단하고 구현하기 쉽다.
	작업이 짧은 작업이나 중요한 작업을 오래 기다리게 할 수 있다.
	평균 반환시간이 길디.
	( 평균 반환시간 = 평균 실행시간 + 평균 대기시간 )

#### 5-4-2 FIFO 평균 반환시간 계산

<img width="462" alt="Pasted Graphic 21" src="https://user-images.githubusercontent.com/88019314/155252973-0a243c35-9cb6-45f4-bd36-533a126d6c48.png">
<br>

	A라는 작업 (프로세스)는 실행시간(추정치) 24이고 도착시간(제출시간)은 0 이다.
	B라는 작업 (프로세스)는 실행시간(추정치) 6이고 도착시간(제출시간)은 1 이다.
	C라는 작업 (프로세스)는 실행시간(추정치) 3이고 도착시간(제출시간)은 2이다.

	실행시간 평균 : 24+6+3 / 3  = 33 / 3 = 11
	대기시간 평균 : A = 0
       B = 24(A의 실행시간) - 1(B의 도착시간) = 23
       C = (24(A의 실행시간) + 6(B의 실행시간)) - 2(C의 도착시간) = 28
	
       0 + 23 + 28 / 3 = 51 / 3 = 17

	평균 반환시간 : 11(평균 실행시간) + 17(평균 대기시간) = 28

### 5-5 SJF(Short Job First) - 비선점형
		
#### 5-5-1 SJF의 특징
	작업이 끝나기까지의 실행시간 추정치가 가장 작은 작업을 먼저 실행시키는 방식이다.
	FIFO보다 평균 대기시간이 작지만 긴 작업의 경우 FIFO 기법보다 더 크고 예측이 더욱 어렵다.
	실행시간이 많은 작업일 경우에 무한 대기 상태가 발생될 수 있다.
	무한 대기 상태를 방지하기 위해 Aging(노화) 기법을 사용하여 해결한다

#### 5-5-2 무한 대기( 무한 정지, 기아) 상태
	어떠한 시스템이든지 자원 할당 스케줄링 및 CPU 스케줄링 결정에 의해서 특정 프로세스가 무한정 기다리는 현상을 말한다.

#### 5-5-3 Aging(에이징, 노화) 기법
	무한 대기 상태를 해결하기 위해서 자원이 할당되기를 오랜 시간 동안 기다린 프로세스에 대하여 기다린 시간에 비례하는 높은 우선순위를
	부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법을 Aging(노화)기법이라고 한다.

#### 5-5-2 SJF 평균 반환시간 계산

<img width="462" alt="Pasted Graphic 21" src="https://user-images.githubusercontent.com/88019314/155252973-0a243c35-9cb6-45f4-bd36-533a126d6c48.png">
<br>

	순서
	A라는 작업 (프로세스)는 실행시간(추정치) 24이고 도착시간(제출시간)은 0 이다.
	C라는 작업 (프로세스)는 실행시간(추정치) 3이고 도착시간(제출시간)은 2이다.
	B라는 작업 (프로세스)는 실행시간(추정치) 6이고 도착시간(제출시간)은 1 이다.
			
	실행시간 평균 : 24+3+6 / 3  = 33 / 3 = 11
	대기시간 평균 :    A = 0
                    C = 24 -2 = 22
                    B = 27 - 1 = 26
		
	                0 + 22 + 26 / 3 = 48 / 3 = 16

	평균 반환시간 : 11(평균 실행시간) + 16(평균 대기시간) = 27

***
<br>

    개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}